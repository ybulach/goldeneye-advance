////////////////
// Inclusions //
////////////////
#include "../Common/Common.h"

///////////
// AUTRE //
///////////
// Variables qui contiennent les anciennes positions traitées
int backgroundX = 0, backgroundY = 0;

// Les pointeurs vers les maps en cours
u16* map_plan;
u16* map_col;

// Si la touche de saut a déjà été appuyée
u8 keyJump = 0;

//////////////////////////////////////////////////
// Il y a 128 sprites au total:					//
// 		0		joueur							//
// 		1-75	ennemis							//
// 		76-127	interface (tir, vies, etc...)	//
//////////////////////////////////////////////////
Sprite sprite[128];

/////////////////////
// jeuResetSprites //
/////////////////////
void jeuResetSprites()
{
	int i;
	
	// Pour chaque sprite du tableau
	for(i = 0; i < 128; i++)
	{
		// On met le sprite en dehors de la map
		sprite[i].x = -240;
		sprite[i].y = -160;
	}
	
	commonResetSprites();
}

/////////////////////
// jeuCreateSprite //
/////////////////////
void jeuCreateSprite(int s, int size, int gfx)
{
    sprite[s].x = 0;
    sprite[s].y = 0;
    sprite[s].jump = 0;
    sprite[s].anim = ANIM_RIEN;
    sprite[s].anim_cnt = 0;
	sprite[s].gfx = gfx;
	sprite[s].size = size;
	
	OAMBuffer[s].attribute0 = COLOR_256 | SQUARE | sprite[s].y;
	OAMBuffer[s].attribute2 = sprite[s].gfx + ANIM(s);
	
	if(size == 8)
		OAMBuffer[s].attribute1 = SIZE_8 | sprite[s].x;
	else if(size == 16)
		OAMBuffer[s].attribute1 = SIZE_16 | sprite[s].x;
	else if(size == 32)
		OAMBuffer[s].attribute1 = SIZE_32 | sprite[s].x;
	else if(size == 64)
		OAMBuffer[s].attribute1 = SIZE_64 | sprite[s].x;
}

////////////////////////
// jeuUpdateSpriteGfx //
////////////////////////
void jeuUpdateSpriteGfx(int s)
{
	commonSpriteChangeGfx(s, sprite[s].gfx + ANIM(s));
}

//////////////////////
// jeuUpdateEnnemis //
//////////////////////
void jeuUpdateEnnemis()
{
	int i;
	
	// Pour chaque ennemi du tableau
	for(i = 1; i < 76; i++)
	{
		// On affiche le personnage à la bonne position
		commonSpriteChangePos(i, sprite[i].x - backgroundX, sprite[i].y - backgroundY);
		
		// Si le personnage est vivant
		if(sprite[i].anim != ANIM_MORT)
		{
			///////////////////////////////////
			// Intelligence Artificielle ICI //
			///////////////////////////////////
		}
	}
}

////////////////
// jeuGetTile //
////////////////
u16 jeuGetTile(int x, int y)
{
	return map_col[(x >> 3) + ((y >> 3) * MAP_WIDTH)];
}

/////////////////
// jeuGetTileX //
/////////////////
int jeuGetTileX(int s, int deltaX)
{
	return ((sprite[s].x + deltaX) >> 3);
}

/////////////////
// jeuGetTileY //
/////////////////
int jeuGetTileY(int s, int deltaY)
{
	return (((sprite[s].y + deltaY) >> 3) * MAP_WIDTH);
}

///////////////////
// jeuCheckColUp //
///////////////////
int jeuCheckColUp(int s)
{
	if(		(jeuGetTile(sprite[s].x + (sprite[s].size >> 1), sprite[s].y) != COL_ALL)
			&& (jeuGetTile(sprite[s].x + (sprite[s].size >> 1), sprite[s].y) != COL_DOWN))
		return 0;
	return 1;
}

/////////////////////
// jeuCheckColDown //
/////////////////////
int jeuCheckColDown(int s)
{
	if(		(jeuGetTile(sprite[s].x + (sprite[s].size >> 1), sprite[s].y + sprite[s].size) != COL_ALL)
			&& (jeuGetTile(sprite[s].x + (sprite[s].size >> 1), sprite[s].y + sprite[s].size) != COL_UP))
		return 0;
	return 1;
}

/////////////////////
// jeuCheckColLeft //
/////////////////////
int jeuCheckColLeft(int s)
{
	if(		(jeuGetTile(sprite[s].x, sprite[s].y + 2) != COL_ALL)
			&& (jeuGetTile(sprite[s].x, sprite[s].y + sprite[s].size - 2) != COL_ALL)
			&& (jeuGetTile(sprite[s].x, sprite[s].y + 2) != COL_RIGHT)
			&& (jeuGetTile(sprite[s].x, sprite[s].y + sprite[s].size - 2) != COL_RIGHT))
		return 0;
	return 1;
}

//////////////////////
// jeuCheckColRight //
//////////////////////
int jeuCheckColRight(int s)
{
	if(		(jeuGetTile(sprite[s].x + sprite[s].size, sprite[s].y + 2) != COL_ALL)
			&& (jeuGetTile(sprite[s].x + sprite[s].size, sprite[s].y + sprite[s].size - 2) != COL_ALL)
			&& (jeuGetTile(sprite[s].x + sprite[s].size, sprite[s].y + 2) != COL_LEFT)
			&& (jeuGetTile(sprite[s].x + sprite[s].size, sprite[s].y + sprite[s].size - 2) != COL_LEFT))
		return 0;
	return 1;
}

/////////////
// jeuJump //
/////////////
void jeuJump(int s)
{
	if(sprite[s].jump > 0)
	{
		// Si il n'y a pas d'obstacle
		if(!jeuCheckColUp(s))
		{
			sprite[s].y--;
			sprite[s].jump--;
		}
		// Si il y a un obstacle
		else
		{
			// On arrête le saut
			sprite[s].jump = 0;
		}
		
		// On change l'animation du sprite
		sprite[s].anim = ANIM_SAUTE;
	}
	else
		sprite[s].jump = 0;
}

////////////////
// jeuGravity //
////////////////
void jeuGravity(int s)
{
	if((sprite[s].jump == 0) && !jeuCheckColDown(s))
	{
		// Début de gravité, chute lente
		sprite[s].y++;
		sprite[s].gravity++;
		
		// Puis on descend plus vite
		if((sprite[s].gravity > 10) && !jeuCheckColDown(s))
		{
			sprite[s].y++;
			sprite[s].gravity++;
		}
		if((sprite[s].gravity > 30) && !jeuCheckColDown(s))
		{
			sprite[s].y++;
			sprite[s].gravity++;
		}
		
		// On change l'animation du sprite
		sprite[s].anim = ANIM_TOMBE;
	}
	else
		sprite[s].gravity = 0;
}

/////////////////////////
// jeuUpdateBackground //
/////////////////////////
void jeuUpdateBackground()
{
	// On calcul les restes des division des coordonnées par 8
	int diffX = backgroundX & 7;
	int diffY = backgroundY & 7;
	
	// On calcul les dimensions à copier
	int copyWidth = (backgroundX + 32 > MAP_WIDTH) ? (MAP_WIDTH - (backgroundX >> 3)) : (32);
	int copyHeight = (backgroundY + 32 > MAP_HEIGHT) ? (MAP_HEIGHT - (backgroundY >> 3)) : (32);
	
	// On traite chaque ligne
	int i;
	for(i = 0; i < copyHeight; i++)
		commonDMACopy((void*)map_plan + (((backgroundX >> 3) + ((backgroundY >> 3) * MAP_WIDTH) + (i * MAP_WIDTH)) << 1), (void*)ScreenBaseBlock(31) + (i << 6), copyWidth, DMA_16NOW);
	
	REG_BG1HOFS = diffX;
	REG_BG1VOFS = diffY;
}

/////////////////
// jeuFocusCam //
/////////////////
void jeuFocusCam(int s)
{
	int posX, posY;
	
	////////////////
	// Position X //
	////////////////
	// Si on a atteint le haut de la map
	if(sprite[s].x < 112)
	{
		// On ne défile plus le background et on déplace le sprite
		backgroundX = 0;
		
		if(sprite[s].x < backgroundX)
			sprite[s].x = 0;
		posX = sprite[s].x;
	}
	// Si on a atteint le bas de la map
	else if(sprite[s].x > (MAP_WIDTH * 8) - SCREEN_WIDTH + 112)
	{
		backgroundX = (MAP_WIDTH * 8) - SCREEN_WIDTH;
		
		if(sprite[s].x > backgroundX - sprite[s].size)
			sprite[s].x = backgroundX - sprite[s].size;
		posX = sprite[s].x - backgroundX;
	}
	// Sinon
	else
	{
		backgroundX = sprite[s].x - 112;
		posX = sprite[s].x - backgroundX;
	}
	
	////////////////
	// Position Y //
	////////////////
	// Si on a atteint le haut de la map
	if(sprite[s].y < 72)
	{
		// On ne défile plus le background et on déplace le sprite
		backgroundY = 0;
		
		if(sprite[s].y < backgroundY)
			sprite[s].y = 0;
		posY = sprite[s].y;
	}
	// Si on a atteint le bas de la map
	else if(sprite[s].y > (MAP_HEIGHT * 8) - SCREEN_HEIGHT + 72)
	{
		backgroundY = (MAP_HEIGHT * 8) - SCREEN_HEIGHT;
		
		if(sprite[s].y > backgroundY - sprite[s].size)
			sprite[s].y = backgroundY - sprite[s].size;
		posY = sprite[s].y - backgroundY;
	}
	// Sinon
	else
	{
		backgroundY = sprite[s].y - 72;
		posY = sprite[s].y - backgroundY;
	}
	
	commonSpriteChangePos(s, posX, posY);
}

/////////
// jeu //
/////////
void jeu()
{
	REG_DISPCNT = MODE_0;
	
	// On remet à zéro les sprites
	jeuResetSprites();
	
	// Un sprite
	jeuCreateSprite(JAMES_BOND, 16, SPRITE_JAMES_BOND);
	
	jeuCreateSprite(1, 16, SPRITE_SCIENTIFIQUE);
	sprite[1].x = 45 * 8;
	sprite[1].y = 13 * 8;
	
	// La palette des maps
	commonDMACopy((void*)exemple_palette, (void*)palette, 256, DMA_16NOW);
	// Les tiles des maps
	commonDMACopy((void*)exemple_tiles, (void*)CharBaseBlock(0), 1024 << 4, DMA_16NOW);
	
	// Une map
	REG_BG2CNT = BG_COLORS_256 | TXTBG_SIZE_256x256 | (0 << 2) | (30 << 8);
	commonDMACopy((void*)exemple_fond_map, (void*)ScreenBaseBlock(30), 32 * 32, DMA_16NOW);
	
	// Une autre map
	REG_BG1CNT = BG_COLORS_256 | TXTBG_SIZE_256x256 | (0 << 2) | (31 << 8);
	map_plan = exemple_plan_map;
	jeuUpdateBackground();
	
	// La map des colisions
	map_col = exemple_col_map;
	
	REG_DISPCNT |= BG1_ENABLE | BG2_ENABLE | OBJ_ENABLE | OBJ_MAP_1D;
	
	while(scene >= JEU)
	{
		// Retour au menu de briefing
		if(!(REG_KEYS & KEY_START))
			scene = MENU_BRIEFING;
		
		// Si la touche droite est appuyée et qu'il n'y a pas d'obstacle
		if(commonCheckKey(KEY_RIGHT) && !jeuCheckColRight(JAMES_BOND))
		{
			sprite[JAMES_BOND].x++;
			
			commonSpriteFlip(JAMES_BOND, 0, 0);
			
			// Si on est au sol
			if((sprite[JAMES_BOND].jump == 0) && jeuCheckColDown(JAMES_BOND))
			{
				// Si le compteur est assez élevé pour changer l'animation
				if(sprite[JAMES_BOND].anim_cnt > 10)
				{
					// Changement de l'animation
					if(sprite[JAMES_BOND].anim >= ANIM_MARCHE3)
						sprite[JAMES_BOND].anim = ANIM_RIEN;
					else
						sprite[JAMES_BOND].anim++;
					
					sprite[JAMES_BOND].anim_cnt = 0;
				}
				else
					sprite[JAMES_BOND].anim_cnt++;
			}
		}
		// Si la touche gauche est appuyée et qu'il n'y a pas d'obstacle
		else if(commonCheckKey(KEY_LEFT) && !jeuCheckColLeft(JAMES_BOND))
		{
			sprite[JAMES_BOND].x--;
			
			commonSpriteFlip(JAMES_BOND, 1, 0);
			
			// Si on est au sol
			if((sprite[JAMES_BOND].jump == 0) && jeuCheckColDown(JAMES_BOND))
			{
				// Si le compteur est assez élevé pour changer l'animation
				if(sprite[JAMES_BOND].anim_cnt > 10)
				{
					// Changement de l'animation
					if(sprite[JAMES_BOND].anim >= ANIM_MARCHE3)
						sprite[JAMES_BOND].anim = ANIM_RIEN;
					else
						sprite[JAMES_BOND].anim++;
					
					sprite[JAMES_BOND].anim_cnt = 0;
				}
				else
					sprite[JAMES_BOND].anim_cnt++;
			}
		}
		// Si on ne fait rien et qu'on est au sol
		else if(!commonCheckKey(KEY_A) && jeuCheckColDown(JAMES_BOND) && (sprite[JAMES_BOND].jump == 0))
		{
			sprite[JAMES_BOND].anim_cnt = 0;
			sprite[JAMES_BOND].anim = ANIM_RIEN;
			
			sprite[JAMES_BOND].jump = 0;
			sprite[JAMES_BOND].gravity = 0;
		}
		
		// Si la touche de saut est appuyée et qu'on n'est pas dans les airs
		if(commonCheckKey(KEY_A) && jeuCheckColDown(JAMES_BOND) && !keyJump)
		{
			sprite[JAMES_BOND].jump = 30;
			keyJump = 1;
		}
		// Si la touche de saut n'est pas appuyée
		if(!commonCheckKey(KEY_A))
		{
			sprite[JAMES_BOND].jump = 0;
			keyJump = 0;
		}
		
		// Saut du joueur
		jeuJump(JAMES_BOND);
		
		// Gravité du joueur
		jeuGravity(JAMES_BOND);
		
		// Centre l'écran sur le joueur
		jeuFocusCam(JAMES_BOND);
		
		// Mise à jour du joueur
		jeuUpdateSpriteGfx(JAMES_BOND);
		
		// Mise à jour des ennemis
		jeuUpdateEnnemis();
		
		// Mise à jour des coordonnées du background
		jeuUpdateBackground();
		
		// Attente de la fin du dessin à l'écran
		commonWaitVSync();
		
		// Copie des sprites dans la mémoire OAM
		commonCopyOAMBuffer();
	}
}
